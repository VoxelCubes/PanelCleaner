# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/visor.ipynb.

# %% ../nbs/visor.ipynb 1
from __future__ import annotations


# %% auto 0
__all__ = ['ContextVisor', 'Spinner']

# %% ../nbs/visor.ipynb 5
from collections import defaultdict
from typing import Any
from typing import TypeAlias

import ipywidgets as W
import traitlets as T
from IPython.display import clear_output
from IPython.display import display
from IPython.display import HTML
from ipywidgets.widgets.interaction import show_inline_matplotlib_plots
from rich.console import Console


# %% ../nbs/visor.ipynb 6
from pcleaner._testbed.testbed.helpers import _pops_
from pcleaner._testbed.testbed.helpers import cleanupwidgets


# %% ../nbs/visor.ipynb 10
console = Console(width=104, tab_size=4, force_jupyter=True)
cprint = console.print


# %% ../nbs/visor.ipynb 12
CtlT: TypeAlias = W.ValueWidget | W.fixed

NO_UI = W.DOMWidget(layout={'display': 'none'})
NO_UI.close()

#| export

UPDATE_SCRIPT = f"""
<script>
    var currentScript = document.currentScript;
    currentScript.parentNode.innerHTML = '';
    # console.log(currentScript);
    # debugger;
</script>
"""


# %% ../nbs/visor.ipynb 13
class ContextVisor:
    ctx: Any
    values: dict[str, Any] = {}

    _ctxs: dict[str, ContextVisor] = {}
    _hdlrs: dict[str, ContextVisor] = {}
    _css: str = ''
    _ctl2name: dict[CtlT, str]
    _name2comp: dict[str, ContextVisor]
    _out: W.Output | None = None
    _w: W.DOMWidget | None = None
    _controls: dict[str, CtlT] | None = None
    _all_controls: dict[str, CtlT] | None = None
    _ui_cls: type[W.Box] = W.HBox
    _inited = False

    @property
    def w(self) -> W.DOMWidget:
        "Container (DOM)widget of this comp."
        if self._inited and self._w is None:
            self._w = self._setup_ui() or NO_UI
        return self._w  # type: ignore
    @property
    def out(self) -> W.Output:
        if self._inited and self._out is None:
            self._out = W.Output()
            self._out.clear_output(wait=True)
        return self._out  # type: ignore
    @property
    def controls(self) -> dict[str, CtlT]:
        if self._controls is None:
            self._controls = self.setup_controls() if self._inited else {}
        return self._controls
    @property
    def all_controls(self) -> dict[str, CtlT]:
        if self._all_controls is None:
            controls = {}
            if self._inited:
                for visor in self._ctxs.values():
                    controls.update(visor.all_controls)
                controls.update(self.controls)
            self._all_controls = controls
            self._ctl2name = {v:k for k,v in controls.items()}
        return self._all_controls  # type: ignore
    
    @property
    def all_values(self):
        """Values from first level comps, keyed by comp name.
        NOTE: will fail for nested contexts or more than one level.
        """
        return {**{k:v.values for k,v in (self.comps | {'self': self}).items()}}
    
    def _all_values(self):
        "Flattened values from all comps"
        all_values = {}
        for comp in [*self.comps.values(), self]: all_values.update(comp.values)
        return all_values

    @property
    def comps(self): return self._ctxs
    def comp(self, k: str) -> ContextVisor | None: return self._ctxs.get(k)
    def handler(self, k: str) -> ContextVisor | None: return self._hdlrs.get(k)
    
    @property
    def styler(self) -> W.HTML | str:
        if getattr(self, '_style', None) is None:
            stl = self.setup_style()
            if stl: 
                stl_id = 'stl-' + str(id(self))
                stl = f"<style id='{stl_id}'>{stl}</style>"
                self._style = W.HTML(stl)
            else:
                self._style = ''
        return self._style
    def setup_style(self):
        collate = [_.setup_style() for _ in self.comps.values()]
        if self._css: collate.append(self._css)
        return '\n'.join([_ for _ in collate if _])
    
    def update_output(self, **kwargs): 
        cprint(kwargs)
    
    def setup_controls(self) -> dict[str, CtlT]:
        widgets = [W.interactive.widget_from_abbrev(v) for k, v in self.values.items()]
        widgets = {k:W.fixed(v) if w is None else w for (k, v), w in zip(self.values.items(), widgets)}
        # return {k: W.Label(value=str(k)) for k,w in self.values.items()}
        return widgets
    
    def hide(self): 
        if (w := self.w) is not NO_UI: 
            w.layout.visibility = 'hidden'
    def show(self): 
        if (w := self.w) is not NO_UI: 
            w.layout.visibility = 'visible'

    def comps_ui(self):
        comps = []
        if self._inited: 
            for visor in self.comps.values():
                if (visor_ui := visor._setup_ui()) is not None:
                    comps.append(visor_ui)
        return comps


    def _setup_ui(self):
        if not self._inited: return
        w = self.setup_ui()
        if w is not None:
            w.add_class('context-visor')
            w.add_class(str(id(self)))
        return w
        
    def setup_ui(self) -> W.DOMWidget | None:
        """Get the container widget for this comp.
        This method should be the only one called when the comp is nested inside other comp.
        """
        uis = [*self.comps_ui(), *self.controls.values()]
        return self._ui_cls(uis) if uis else None

    def setup_display(self): 
        "Generates one time ui"
        if not self._inited: return
        if self._w is None:
            self._w = self._setup_ui()
        

    def _output(self, **kwargs):
        # group keys by comp
        collator = defaultdict(dict)
        for k,v in kwargs.items():
            if (comp := self.handler(k)) is not None:
                collator[comp][k] = v
            else:
                # keys w/out control assigned, considered internal state
                collator[self][k] = v
        # group comps by output
        outs = defaultdict(list)
        for comp, kw in collator.items():
            outs[comp.out].append((comp, kw))
        for out, g in outs.items():
            show_inline_matplotlib_plots()
            with out:
                clear_output(wait=True)
                for comp, kw in g:
                    comp.update_output(**kw)
                show_inline_matplotlib_plots()

    def _observe(self, change):
        control_name = self._ctl2name[change['owner']]
        kwargs = {control_name: change['new']}
        updated = self._update(**kwargs)
        self._output(**updated)
    def setup_ux(self): pass
    def _setup_ux(self): 
        for visor in self.comps.values():
            visor._setup_ux()
        self.setup_ux()
    def interactive_output(self):
        controls = self.all_controls
        all_values = self._all_values()
        for k,w in controls.items():
            if k in all_values:
                w.observe(self._observe, 'value')
    
    def display(self, **kwargs): 
        if not self._inited: return
        if self._w is None:
            self.setup_display()
            self.interactive_output()
            self._update(**(self.values | kwargs))
            all_values = self._all_values()
            self._hdlrs = {k:self._hdlrs.get(k, self) for k in all_values}
            self._output(**all_values)
            # ux final touches once everything (including outputs) is setup
            # for visor in [*self.comps.values(), self]:
            #     visor.setup_ux()
            self._setup_ux()
            stl = self.styler
            ui: list = [stl] if stl else []
            if (w := self.w) is not NO_UI:
                ui.append(w)
            for comp in [*self.comps.values(), self]:
                if comp._out is not None:
                    ui.append(comp._out)
            self._final = W.VBox(ui)
            self._display_handle = display(self._final, display_id=str(id(self)))
        else:
            self.update(**kwargs)
    def _ipython_display_(self): self.display()

    def _update(self, update_value: bool=True, **kwargs):
        updated = {}
        for visor in self.comps.values():
            updated.update(visor._update(update_value=update_value, **kwargs))
        values = self.values
        my_vals = _pops_(kwargs, self.values.keys())
        for k,v in my_vals.items():
            if v is not None and v != values[k]:
                if update_value: 
                    values[k] = v
                updated[k] = v
        return updated
    def update(self, **kwargs):
        updated = self._update(update_value=False, **kwargs)
        controls = self.all_controls
        for k,v in updated.items():
            if k in controls:
                if hasattr((ctl := controls[k]), 'value'):
                    ctl.value = v  # will trigger update (self._observe)
            elif k in (vv := self._name2comp):
                # update manually
                comp = vv[k]
                if v != comp.values[k]:
                    comp.values[k] = v
                    self._output(**{k:v})
    

    def close(self):
        controls = self.all_controls
        for w in controls.values():
            try: w.unobserve(self._observe, 'value')
            except: pass
            if isinstance(w, W.Widget):
                w.close()
        for visor in self._ctxs.values():
            if w := getattr(visor, '_w', None): w.close()
            if visor._out is not self._out:
                if o := getattr(visor, '_out', None): o.close()
            visor.close()
        if w := getattr(self, '_w', None): w.close()
        if o := getattr(self, '_out', None): o.close()
        if f := self._final: f.close()
        if self._display_handle is not None:
            self._display_handle.update(HTML(UPDATE_SCRIPT))


    def __del__(self): 
        self.close()

    def __init__(self, 
            ctx: Any, 
            values: dict[str, Any], 
            out: W.Output | None = None,
            ctxs: dict[str, ContextVisor] | None = None,
            hdlrs: dict[str, ContextVisor] | None = None,
            css: str | None = None,
        ):
        # Only setup some state. Controls, values and containers will be setup only when explicitly displayed
        self._display_handle = None
        self._final = None
        self.ctx = ctx
        self.values = values or {}
        self._out = out
        self._ctxs = comps = ctxs or {}
        self._hdlrs = hdlrs or {}
        if css is not None:
            self._css = css
        self._name2comp = name2comp = {}
        for n,vv in self.all_values.items():
            comp = comps.get(n, self)
            for k in vv:
                name2comp[k] = comp
        self._inited = True


# %% ../nbs/visor.ipynb 25
spinner_css = """
    .wrapper-spinner {
        overflow: hidden;
        width: fit-content;
        height: fit-content;
    }
    
    .loading-spinner {
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid white;
        border-radius: 50%;
    }
    
    .spinner {
        border: |border_width|px solid rgba(128,128,128,.5);
        border-radius: 50%;
        border-left-color: red;
        animation: spin 1s infinite linear;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
"""


# %% ../nbs/visor.ipynb 32
class Spinner(ContextVisor):
    ctx: T.HasTraits

    def loading_spinner(self, size=36, border_width=4):
        bw = border_width*2
        html: str = f'''
<div class="loading-spinner" style="width: {size + bw}px; height: {size + bw}px;">
    <div class="spinner" style="width: {size}px; height: {size}px;"></div>
</div>
    '''
        return html
    
    def setup_controls(self):
        spinner = W.HTML(self.loading_spinner(self.size, self.border_width))
        spinner.add_class('wrapper-spinner')
        return {'spinner': spinner}

    @property
    def spinner(self) -> W.HTML: return self.controls['spinner']  # type: ignore

    def hide(self): self.spinner.layout.display = 'none'
    def show(self): self.spinner.layout.display = 'block'

    def setup_ux(self):
        source = (self.ctx, '_running')
        target = (self.spinner.layout, 'display')
        self._link = T.dlink(source, target, lambda x: 'block' if x else 'none')

    def close(self):
        if l := getattr(self, '_link', None): l.unlink()
        super().close()

    def __init__(self, 
            ctx: T.HasTraits,
            size: int = 24,
            border_width: int = 4,
            **kwargs
        ):
        self.size = size
        self.border_width = border_width
        self._link = None
        super().__init__(ctx, {}, css=spinner_css.replace('|border_width|', str(border_width)), **kwargs)

