# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/experiments.ipynb.

# %% ../nbs/experiments.ipynb 1
from __future__ import annotations


# %% auto 0
__all__ = ['CM', 'SubjIdT', 'RunIdT', 'SubjSpecT', 'ImgIdT', 'ImgSpecT', 'BoxIdT', 'remove_multiple_whitespaces',
           'postprocess_ocr', 'accuracy_ocr_naive', 'accuracy_ocr_difflib', 'ground_truth_path', 'read_ground_truth',
           'dilate_by_fractional_pixel', 'extract_text', 'lang2pcleaner', 'lang2tesseract', 'CropMethod',
           'crop_by_image', 'crop_by_extracted', 'ExperimentSubject', 'Result', 'ExperimentRun', 'ExperimentContext',
           'ImageContext', 'ResultOCR', 'ResultOCRExtracted', 'ResultSet', 'ResultSetDefault', 'resultset_to_dict',
           'dict_to_resultset', 'OCRModel', 'OCRExperimentRun', 'OCRExperimentContext', 'SimpleResultVisor',
           'RunSelector', 'MessageVisor', 'StatusVisor', 'OCRModelSelector', 'DisplayOptions', 'ContentSelector',
           'ImageSelector', 'OCRContextVisor', 'ImageContextVisor', 'ExperimentOCR', 'ExperimentOCRMethod',
           'ResultVisor', 'ExperimentVisor', 'ExperimentsVisor']

# %% ../nbs/experiments.ipynb 11
import contextlib
import dataclasses
import datetime
import difflib
import functools
import json
import os
import shutil
import tempfile
from collections import defaultdict
from enum import Enum
from pathlib import Path
from typing import Any
from typing import Callable
from typing import cast
from typing import Mapping
from typing import TypeAlias

import fastcore.all as FC
import ipywidgets as W
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pcleaner.config as cfg
import pcleaner.ctd_interface as ctm
import pcleaner.image_ops as ops
import pcleaner.ocr.ocr as ocr
import pcleaner.structures as st
import torch
import traitlets as T
from IPython.display import clear_output
from IPython.display import display
from IPython.display import HTML
from loguru import logger
from pcleaner.ocr.ocr_tesseract import TesseractOcr
from PIL import Image
from PIL import ImageFilter
from rich.console import Console
from tqdm.notebook import tqdm

from .helpers import *
from .ocr_metric import *
from .visor import ContextVisor
from .visor import Spinner
from .web_server import WebServer
from .web_server import setup_ngrok
from .web_server import WebServerBottle


# %% ../nbs/experiments.ipynb 16
console = Console(width=104, tab_size=4, force_jupyter=True)
cprint = console.print


# %% ../nbs/experiments.ipynb 19
os.environ['USE_PIL'] = 'False'
os.environ['USE_TUNNEL'] = 'False'
SERVER = None


# %% ../nbs/experiments.ipynb 55
def remove_multiple_whitespaces(text):
    return ' '.join(text.split())

    
def postprocess_ocr(text):
    "Basic postprocessing for English Tesseract OCR results."
    return ' '.join(remove_multiple_whitespaces(text).splitlines()).capitalize()

def accuracy_ocr_naive(text, ground_truth):
    return sum(1 for a, b in zip(text, ground_truth) if a == b) / len(text)


def accuracy_ocr_difflib(text, ground_truth):
    """
    Calculates the OCR accuracy based on the similarity between the OCR text and the ground truth text,
    using difflib's SequenceMatcher to account for differences in a manner similar to git diffs.

    :param text: The OCR-generated text.
    :param ground_truth: The ground truth text.
    :return: A float representing the similarity ratio between the OCR text and the ground truth, 
            where 1.0 is identical.
    """
    # Initialize the SequenceMatcher with the OCR text and the ground truth
    matcher = difflib.SequenceMatcher(None, text, ground_truth)
    
    # Get the similarity ratio
    similarity_ratio = matcher.ratio()
    
    return similarity_ratio

# %% ../nbs/experiments.ipynb 57
def ground_truth_path(page_data: st.PageData):
    path = Path(page_data.original_path)
    return path.with_stem(path.stem + '_gt').with_suffix('.txt')


def read_ground_truth(page_data: st.PageData, root_dir: Path):
    gts_path = root_dir / ground_truth_path(page_data)
    if gts_path.exists():
        gts = gts_path.read_text(encoding="utf-8").splitlines()
    else:
        gts = ["" for _ in range(len(page_data.boxes))]
    return gts


# %% ../nbs/experiments.ipynb 59
def dilate_by_fractional_pixel(image, dilation_fraction, filter_base_size=3):
    """
    Dilates an image by a specified fractional pixel amount. The function calculates 
    the necessary scaling factor and filter size based on the desired dilation fraction.

    :param image: A PIL Image object (1-bit mode).
    :param dilation_fraction: The desired fractional pixel amount for dilation (e.g., 0.2).
    :param filter_base_size: The base size of the dilation filter to apply on the scaled image.
                             This size is adjusted based on the scaling factor to achieve the
                             desired dilation effect.
    :return: A PIL Image object after dilation, converted back to grayscale.
    """
    from PIL.Image import Resampling
    # Calculate the scale factor based on the desired dilation fraction
    scale_factor = int(1 / dilation_fraction)
    
    # Adjust the filter size based on the scale factor
    # This ensures the dilation effect is proportional to the desired fraction
    filter_size = max(1, filter_base_size * scale_factor // 5)

    # Convert the image to grayscale for more nuanced intermediate values
    image_gray = image.convert("L")

    # Resize the image to a larger size using bicubic interpolation
    larger_size = (int(image.width * scale_factor), int(image.height * scale_factor))
    image_resized = image_gray.resize(larger_size, Resampling.BICUBIC)

    # Apply the dilation filter to the resized image
    dilated_image = image_resized.filter(ImageFilter.MaxFilter(filter_size))

    # Resize the image back to its original size using bicubic interpolation
    image_dilated_fractional_pixel = dilated_image.resize(image.size, Resampling.BICUBIC)

    return image_dilated_fractional_pixel


# %% ../nbs/experiments.ipynb 60
def extract_text(image, text_mask, box):
    cropped_image = crop_box(box, image)
    cropped_mask = crop_box(box, text_mask)
    extracted = ops.extract_text(cropped_image, cropped_mask)
    return cropped_image, cropped_mask, extracted


# %% ../nbs/experiments.ipynb 62
_lang2pcleaner = {'English': st.DetectedLang.ENG, 'Japanese': st.DetectedLang.JA, 'Spanish': st.DetectedLang.ENG,
                    'French':st.DetectedLang.ENG}
# _lang2tesseract = {'English': 'eng', 'Japanese': 'jpn'}
_lang2tesseract = {'English': 'eng', 'Japanese': 'jpn_vert', 'Spanish': 'spa', 'French': 'fra'}


# %% ../nbs/experiments.ipynb 63
def lang2pcleaner(lang: str):
    return _lang2pcleaner[lang]

def lang2tesseract(lang: str):
    return _lang2tesseract[lang]


# %% ../nbs/experiments.ipynb 66
class CropMethod(Enum):
    INITIAL_BOX = 'Initial box'
    DEFAULT = 'Default'
    DEFAULT_GREY_PAD = 'Default, grey pad'
    PADDED_4 = 'Padded 4px'
    PADDED_8 = 'Padded 8px'
    EXTRACTED_INIT_BOX = 'Extracted, init box'
    PADDED_4_EXTRACTED = 'Padded 4, extracted'
    PADDED_8_EXTRACTED = 'Padded 8, extracted'
    PADDED_8_DILATION_1 = 'Padded 8, dilation 1'
    PAD_8_FRACT_0_5 = 'Pad 8, fract. 0.5'
    PAD_8_FRACT_0_2 = 'Pad 8, fract. 0.2'

    @classmethod
    def __display_names__(cls):
        return dict(
            zip([_.value for _ in cls], 
            cls))


CM = CropMethod

_IMAGE_METHODS = [CM.INITIAL_BOX, CM.DEFAULT, CM.DEFAULT_GREY_PAD, 
                    CM.PADDED_4, CM.PADDED_8]
_EXTRACTED_METHODS = [CM.EXTRACTED_INIT_BOX, CM.PADDED_4_EXTRACTED, 
                        CM.PADDED_8_EXTRACTED, CM.PADDED_8_DILATION_1, 
                        CM.PAD_8_FRACT_0_5, CM.PAD_8_FRACT_0_2]


def crop_by_image(method: CM, 
        box: st.Box, 
        base: Image.Image, 
        preproc: cfg.PreprocessorConfig,
    ):
    image = None
    match method:
        case CM.INITIAL_BOX :
            image = crop_box(box, base)
        case CM.DEFAULT:
            padded2_4 = (
                box.pad(preproc.box_padding_initial, base.size).right_pad(
                            preproc.box_right_padding_initial, base.size))
            image = crop_box(padded2_4, base)
        case CM.DEFAULT_GREY_PAD:
            image = crop_box(box, base)
            image = ops.pad_image(image, 8, fill_color=(128, 128, 128))
        case CM.PADDED_4:
            padded4 = box.pad(4, base.size)
            image = crop_box(padded4, base)
        case CM.PADDED_8:
            padded4 = box.pad(8, base.size)
            image = crop_box(padded4, base)
        case _: pass
    return image


def crop_by_extracted(method: CM, 
        box: st.Box, 
        base: Image.Image, 
        mask: Image.Image,
        cropped_image_path: Path,
        cropped_mask_path: Path,
        dilated: dict[float, Image.Image]
    ):
    cropped_image, cropped_mask, image = None, None, None
    if method in _EXTRACTED_METHODS:
        if not cropped_image_path.exists() or not cropped_mask_path.exists():
            match method:
                case CM.EXTRACTED_INIT_BOX:
                    cropped_image, cropped_mask, image = extract_text(base, mask, box)
                case CM.PADDED_4_EXTRACTED:
                    padded4 = box.pad(4, base.size)
                    cropped_image, cropped_mask, image = extract_text(base, mask, padded4)
                case CM.PADDED_8_EXTRACTED:
                    padded8 = box.pad(8, base.size)
                    cropped_image, cropped_mask, image = extract_text(base, mask, padded8)
                case CM.PADDED_8_DILATION_1:
                    padded8 = box.pad(8, base.size)
                    cropped_image, cropped_mask, image = extract_text(
                                                        base, dilated[1], padded8)
                case CM.PAD_8_FRACT_0_5:
                    padded8 = box.pad(8, base.size)
                    cropped_image, cropped_mask, image = extract_text(
                                                        base, dilated[0.5], padded8)
                case CM.PAD_8_FRACT_0_2:
                    padded8 = box.pad(8, base.size)
                    cropped_image, cropped_mask, image = extract_text(
                                                        base, dilated[0.2], padded8)
                case _: pass

    return image, cropped_image, cropped_mask



# %% ../nbs/experiments.ipynb 68
SubjIdT: TypeAlias = int
RunIdT: TypeAlias = str
SubjSpecT: TypeAlias = SubjIdT | str | Path


class ExperimentSubject:
    exp: ExperimentContext
    idx: SubjIdT

    def setup(self, exp: ExperimentContext, idx: Any, *args, **kwargs): 
        self.exp = exp
        self.idx = cast(SubjIdT, exp.normalize_idx(idx))
        return self

    def __new__(cls, exp: ExperimentContext, idx: Any, *args, **kwargs):
        idx = exp.normalize_idx(idx)
        self = exp.subject_context(idx)
        if self is None:
            self = super().__new__(cls)
            self = exp.setup_subject_context(idx, self, *args, **kwargs)
            if self is None:
                raise ValueError(f"Can't create new subject with idx: {idx}: out of range")
        return self


class Result:
    subject_ctx: ExperimentSubject

class ExperimentRun:
    "A set of experiment results obtained with the same parameters."
    exp: ExperimentContext
    name: RunIdT
    dt: datetime.datetime

    def setup(self, exp: ExperimentContext, name: RunIdT, *args, **kwargs): 
        self.exp = exp
        self.name = name
        return self

    @classmethod
    def setup_run_name(cls, name: RunIdT, dt: datetime.datetime):
        return f"{name}_{dt.strftime('%Y%m%d-%H%M%S')}"

    def setup_run(self, args, **kwargs):
        pass
    def before_result(self, *args, **kwargs):
        pass
    def after_result(self, result: Result, *args, **kwargs):
        pass
    
    def __new__(cls, exp: ExperimentContext, name: RunIdT, *args, **kwargs):
        self = exp.experiment_run(name)
        if self is None:
            self = super().__new__(cls)
            self = exp.setup_experiment_run(name, self, *args, **kwargs)
        return self


class ExperimentContext(T.HasTraits):
    "Class to maintain shared state across all file-based experiments within the experiment domain."
    name: str
    _results: dict[RunIdT, dict[SubjIdT, Any]]

    _dirty = T.Bool(default_value=False)

    CACHE_DIR_NAME: str = 'cache'
    SOURCE_DIR_NAME: str = 'source'
    EXP_DIR: Path = Path("../experiment")

    subject_cls: Callable[..., ExperimentSubject]
    def subject_factory(self) -> Callable[..., ExperimentSubject]: return type(self).subject_cls

    def normalize_idx(self, idx: SubjSpecT) -> SubjIdT | None:
        nidx = None
        if isinstance(idx, int) and idx < self.subject_count:
            nidx = idx
        elif isinstance(idx, str):
            try:
                nidx = [_.name for _ in self._paths].index(idx)
            except Exception:
                pass
        elif isinstance(idx, Path):
            if idx in self._paths:
                nidx = self._paths.index(idx)
        return nidx
    
    def path_from_idx(self, idx: SubjSpecT):
        "Relative path to the subject with the given index."
        _idx = self.normalize_idx(idx)
        if _idx is None:
            raise ValueError(f"{_idx} not found in context.")
        path = Path(self._paths[_idx])
        if not path.resolve().exists():
            raise ValueError(f"{path} not found in context.")
        return path
    
    @property
    def subject_count(self): return len(self._paths)

    @property
    def run_names(self):
        return list(self._exp_runs.keys())

    @property
    def root_dir(self): return self._root
    # Relative paths to `root_dir`
    @property
    def cache_dir(self): return Path(self.CACHE_DIR_NAME)
    @property
    def source_dir(self): return Path(self.SOURCE_DIR_NAME)
    @functools.lru_cache()
    def _subject_cache_dir(self, idx: SubjIdT):
        path = self.path_from_idx(idx)
        subject_cache_dir = self.cache_dir / path.stem
        self.final(subject_cache_dir).mkdir(parents=True, exist_ok=True)
        return subject_cache_dir
    def subject_cache_dir(self, idx: SubjSpecT):
        "Folder to cache and save subject results. Create if needed."
        return self._subject_cache_dir(idx)
    def final(self, path: Path | str): 
        """`path` relative to the root of the experiment.
        If `path` is absolute, it must be in the experiment directory.
        """
        if isinstance(path, str):
            path = Path(path)
        if path.is_absolute():
            try:
                path = path.relative_to(self.root_dir.resolve())
            except Exception:
                return Path('_not_found_/'+path.name)
        return self.root_dir / path
    
    def empty_cache(self, idx: SubjIdT | None = None):
        if idx is None:
            cache_dir = self.final(self.cache_dir)
            shutil.rmtree(cache_dir, ignore_errors=True)
            cache_dir.mkdir(parents=True, exist_ok=True)
        else:
            subject_cache_dir = self.final(self.subject_cache_dir(idx))
            shutil.rmtree(subject_cache_dir, ignore_errors=True)
            subject_cache_dir.mkdir(parents=True, exist_ok=True)
    def empty_cache_warning(self, 
            idx: SubjIdT | None=None, *, warn: bool=True, out: W.Output | None=None):
        def on_confirm_clicked(b):
            try:
                self.empty_cache(idx)
                print("Cache cleared successfully.")
            except Exception as e:
                print(f"Failed to clear cache: {e}")
            finally:
                for widget in confirmation_box.children:
                    widget.close()

        def on_cancel_clicked(b):
            print("Cache clear cancelled.")
            for widget in confirmation_box.children:
                widget.close()

        if out is None:
            out = W.Output()
        cache_name = '' if idx is None else f" of '{self.subject_cache_dir(idx).name}'"
        text = f"Are you sure you want to clear the cache{cache_name}? This action cannot be undone."
        with out:
            if FC.IN_NOTEBOOK:
                confirm_button = W.Button(description="Confirm")
                cancel_button = W.Button(description="Cancel")
                confirm_button.on_click(on_confirm_clicked)
                cancel_button.on_click(on_cancel_clicked)
                label = W.Label(text, style={'font_size': '1.25em', 'font_weight': 'bold'})
                confirmation_box = W.VBox([label, W.HBox([confirm_button, cancel_button])])
                display(confirmation_box)
            else:
                on_confirm_clicked(None)
        return out

    def subject_context(self, idx: SubjSpecT):
        "Cached subject."
        if (nidx := self.normalize_idx(idx)) is None:
            return None
        return self._subjects.get(nidx)
    def setup_subject_context(self, idx: SubjIdT, /, subject: ExperimentSubject, *args, **kwargs):
        "Setup and set cached subject."
        if idx < 0 or idx >= self.subject_count:
            raise ValueError(f"Can't create new subject with idx: {idx}: out of range")
        subject.setup(self, idx, *args, **kwargs)
        self._subjects[idx] = subject
        return subject

    def experiment_run(self, name: RunIdT | None = None):
        "Experiment run `name` or the last one if `name` is None or None"
        if name: 
            return self._exp_runs.get(name)
        if self._exp_runs:
            return self._exp_runs[list(self._exp_runs.keys())[-1]]
        return None
    def setup_experiment_run(self, name: str, run: ExperimentRun, *args, **kwargs):
        "Set or replace cached experiment run."
        run.setup(self, name, *args, **kwargs)
        self._exp_runs[name] = run
        return run

    def _reset_(self):
        # start over. Note: doesn't change _dirty status, intended for use in testing.
        self._subjects.clear()
        self._subject_cache_dir.cache_clear()

    def cleanup_model(self):
        pass

    def __init__(self, name: str, paths: list[Path], root: Path | None = None, run_name: str = 'run1'):
        self.name = name
        self._root = root or type(self).EXP_DIR
        self._paths = paths  # relative paths wrt self._root
        self._subjects: dict[SubjIdT, ExperimentSubject] = {}
        self._exp_runs: dict[str, ExperimentRun] = {}
        self._results = {}
        # default run
        ExperimentRun(self, run_name)


# %% ../nbs/experiments.ipynb 78
ImgIdT = SubjIdT
ImgSpecT: TypeAlias = ImgIdT | str | Path


class ImageContext(ExperimentSubject):
    """
    A utility class to maintain image state for a ExperimentContext.

    Attributes:
        json_data (dict): JSON data loaded from cached files.
        page_data (st.PageData): PanelClaner page data.
        base_image (Image.Image): The base image loaded from the cache.
        mask (Image.Image): The mask image used for text detection.
        gts (list[str]): Ground truth data for the text in the images.
        mask_dilated1 (Image.Image): Image mask dilated by 1 pixel.
        mask_dilated05 (Image.Image): Image mask dilated by 0.5 pixels.
        mask_dilated02 (Image.Image): Image mask dilated by 0.2 pixels.

    """
    exp: ExperimentContext
    idx: ImgIdT
    base_image: Image.Image
    mask: Image.Image
    json_data: dict | None
    page_data: st.PageData
    _page_lang: str
    _gts: list[str]
    _mask_dilated1: Image.Image | None
    _mask_dilated05: Image.Image | None
    _mask_dilated02: Image.Image | None
    
    def to_dict(self):
        return {
            'image_idx': self.idx,
            'page_lang': self.page_lang,
        }
    
    @property
    def image_idx(self): return self.idx
    @property
    def cache_dir(self): 
        "Relative path of the cache directory for this image."
        return self.exp.subject_cache_dir(self.idx)
    
    @property
    def image_info(self): 
        img = self.base_image
        w, h = img.size
        print_size_in = size(w, h, 'in', 300)
        print_size_cm = size(w, h, 'cm', 300)
        required_dpi = dpi(w, h, 'Modern Age')
        return (w, h),  print_size_in, print_size_cm, required_dpi

    @property
    def original_image_path(self): return Path(self.page_data.original_path)
    @property
    def image_path(self): return Path(self.page_data.image_path)
    @property
    def mask_path(self): return Path(self.page_data.mask_path)
    @property
    def image_boxes_path(self):
        exp, img_path = self.exp, self.image_path
        if exp.final( p := img_path.with_stem(img_path.stem + '_boxes')).exists(): 
            return p
        _, p = page_boxes(self.page_data, exp.final(img_path))
        return p.relative_to(exp.root_dir)
    
    # Base image properties 
    @property
    def image_name(self): return self.original_image_path.name
    @property
    def image_size(self): return self.base_image.size
    @property
    def image_dim(self):return size(*self.image_size)
    @property
    def image_dpi(self): return dpi(*self.image_size)
    @property
    def image_print(self):
        return self.image_size, self.image_dim, self.image_dpi
    @property
    def image_name_rich(self):
        siz, dim, res = self.image_print
        return f"{self.image_name} - {siz[0]}x{siz[1]} px: {dim[0]:.2f}x{dim[1]:.2f}\" @ {res:.2f} dpi"
    
    def setup_page_lang(self, page_lang: str | None = None):
        path = self.exp.final(self.page_data.original_path).with_suffix('.json')
        metadata = json.load(open(path)) if path.exists() else {}
        if 'lang' in metadata and (page_lang == metadata['lang'] or page_lang is None):
            self._page_lang = metadata['lang']
            return
        self._page_lang = metadata['lang'] = page_lang or 'English'
        json.dump(metadata, open(path, 'w'), indent=2)
    @property
    def page_lang(self):
        if self._page_lang == None:
            self.setup_page_lang()
        return self._page_lang
    
    @property
    def boxes(self): return self.page_data.boxes
    
    def setup_ground_truth(self):
        self._gts = read_ground_truth(self.page_data, self.exp.root_dir)
    @property
    def gts(self): 
        if self._gts is None:
            self.setup_ground_truth()
        return self._gts
    
    @functools.lru_cache(typed=True)
    def dilated_mask(self, fraction: float):
        return dilate_by_fractional_pixel(self.mask, fraction)
    
    def mask_dilated1(self): 
        if self._mask_dilated1 is None:
            self._mask_dilated1 = self.mask.filter(ImageFilter.MaxFilter(3))
        return self._mask_dilated1
    
    def mask_dilated05(self): 
        if self._mask_dilated05 is None:
            self._mask_dilated05 = self.dilated_mask(0.5)
        return self._mask_dilated05
    
    def mask_dilated02(self): 
        if self._mask_dilated02 is None:
            self._mask_dilated02 = self.dilated_mask(0.2)
        return self._mask_dilated02
    
    def dilated(self):
        return {1: self.mask_dilated1(),
                0.5: self.mask_dilated05(),
                0.2: self.mask_dilated02(),}

    def __new__(cls,
            exp: ExperimentContext,
            idx: ImgSpecT,
            *args, **kwargs) -> 'ImageContext':
        return super().__new__(cls, exp, idx, *args, **kwargs)  # type: ignore


# %% ../nbs/experiments.ipynb 80
@dataclasses.dataclass
class ResultOCR(Result): 
    subject_ctx: ImageContext
    block_idx: int
    ocr: str | None = None
    image: Image.Image | None = None
    description: str = dataclasses.field(default='', kw_only=True)

    def __post_init__(self): 
        self._acc = None
        if self.image is None:
            cache_path = self.image_ctx.exp.final(self.cache_path())
            if cache_path.exists():
                self.image = Image.open(cache_path)

    @property
    def image_ctx(self): return self.subject_ctx
    
    @property
    def acc(self):
        if self.ocr is not None:
            self._acc = accuracy_ocr_difflib(self.ocr, self.image_ctx.gts[self.block_idx])
        return self._acc
    @property
    def suffix(self): return f"{self.block_idx}_{self.description}"

    def cache_path(self, suffix: str | None = None): 
        img_ctx = self.image_ctx
        suffix = self.suffix + (('_'+suffix) if suffix else '')
        img_name = img_ctx.image_path.stem
        return img_ctx.cache_dir / '.crop' / f"{img_name}_{suffix}.png"
    
    def cache_image(self, image: Image.Image | None = None, suffix: str | None = None):
        image = image or (self.image if not suffix else None)
        box_image_path = self.cache_path(suffix)
        final_path = self.image_ctx.exp.final(box_image_path)
        if image and not final_path.exists():
            final_path.parent.mkdir(parents=True, exist_ok=True)
            image.save(final_path)
        return box_image_path

    def to_dict(self):
        d = dataclasses.asdict(self)
        d['image_ctx'] = d['image'] = d['page_data'] = d['gts'] = None
        return d

    # @classmethod
    # def from_dict(cls, d: dict, page_data: st.PageData, gts: list[str]):
    #     return cls(**(d | {'page_data':page_data, 'gts':gts}))

    def __repr__(self): 
        return f"{type(self).__name__}#block {self.block_idx:02}: {self.acc:.2f}||{self.ocr}"

    def display(self): 
        visor = getattr(self, '_default_visor_type', None)
        display(HTML(
            visor(self).as_html() if visor else f"{self}"
            ))
    def _ipython_display_(self): self.display()


class ResultOCRExtracted(ResultOCR): 
    def __repr__(self): return super().__repr__()


# %% ../nbs/experiments.ipynb 82
BoxIdT: TypeAlias = int

class ResultSet(dict[BoxIdT, dict[CropMethod, ResultOCR]]): ...

class ResultSetDefault(defaultdict[BoxIdT, dict[CropMethod, ResultOCR]]): ...

def resultset_to_dict(results: ResultSet) -> dict[BoxIdT, dict[str, str]]:
    d = {}
    for box, box_methods in results.items():
        for method, result in box_methods.items():
            if box not in d:
                d[box] = {}
            d[box][method.name] = result.ocr
    return d

def dict_to_resultset(
        image_idx: ImgIdT, 
        results_dict: dict[str, dict[str, str]],
        result_factory: Callable
    ) -> ResultSetDefault:
    results = ResultSetDefault(dict[CropMethod, ResultOCR])
    for box_idx, box_methods in results_dict.items():
        box_idx = int(box_idx)
        for method, ocr in box_methods.items():
            m = CM[method]
            results[box_idx][m] = result_factory(image_idx, box_idx, m, ocr)
    return results


# %% ../nbs/experiments.ipynb 84
class OCRModel(Enum):
    TESSERACT = 0
    IDEFICS = 1
    @staticmethod
    def __display_names__() -> dict[str, OCRModel]:
        return dict(
            zip("Tesseract, Idefics".split(', '), 
            OCRModel))


class OCRExperimentRun(ExperimentRun): ...


class OCRExperimentContext(ExperimentContext):
    """
    A utility class to maintain shared state across all experiments within OCR domain.
    This class encapsulates state necessary for conducting PanelCleaner OCR experiments.
    """

    config: cfg.Config
    image_paths: list[Path]
    ocr_model: str
    force_PIL: bool
    use_tunnel: bool
    server: web_server.WebServer | None

    # ExperimentRun name -> Image index -> Box index -> Crop method -> Result
    _results: dict[RunIdT, dict[ImgIdT, ResultSet]]

    _running = T.Bool(False)
    
    engines = {
        'Tesseract': cfg.OCREngine.TESSERACT, 
        'Idefics': None, 
        'manga-ocr': cfg.OCREngine.MANGAOCR}


    @classmethod
    def get_config(cls) -> cfg.Config:
        config = cfg.load_config()
        profile = config.current_profile
        preprocessor_conf = profile.preprocessor
        # Modify the profile to OCR all boxes.
        # Make sure OCR is enabled.
        preprocessor_conf.ocr_enabled = True
        # Make sure the max size is infinite, so no boxes are skipped in the OCR process.
        preprocessor_conf.ocr_max_size = 10**10
        # Make sure the sus box min size is infinite, so all boxes with "unknown" language are skipped.
        preprocessor_conf.suspicious_box_min_size = 10**10
        # Set the OCR blacklist pattern to match everything, so all text gets reported in the analytics.
        preprocessor_conf.ocr_blacklist_pattern = ".*"

        # Load models if needed
        gpu = torch.cuda.is_available() or torch.backends.mps.is_available()
        model_path = config.get_model_path(gpu)
        if model_path is None:
            # don't mess with normal PanelCleaner, download models directly
            import pcleaner.model_downloader as md
            model_dir = config.get_model_cache_dir()
            config.default_torch_model_path = md.download_torch_model(model_dir)
            config.default_cv2_model_path = md.download_cv2_model(model_dir)

        return config
        
    @functools.lru_cache()
    def mocr(self, lang: str):
        engine = self.engines[self.ocr_model]
        ocr_processor = ocr.get_ocr_processor(True, engine)
        proc = ocr_processor[lang2pcleaner(lang)]
        if isinstance(proc, TesseractOcr):
            proc.lang = lang2tesseract(lang)
        return proc

    @contextlib.contextmanager
    def running(self, value: bool):
        _running = self._running
        self._running = value
        yield
        self._running = _running

    def ocr_box(self, result: ResultOCR, lang: str): 
        assert result.image is not None
        text = self.mocr(lang)(result.image)
        result.ocr = postprocess_ocr(text)
        self._dirty = True
        return result

    image_cache_dir = ExperimentContext.subject_cache_dir

    def _detect_text(self, img_path: Path, dest_dir: Path):
        config = self.config
        root_dir = self.root_dir
        image_name = img_path.stem
        pfl = config.current_profile
        gpu = torch.cuda.is_available() or torch.backends.mps.is_available()
        model_path = config.get_model_path(gpu)
        json_data = None
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            ctm.model2annotations(pfl.general, pfl.text_detector, model_path, [img_path], temp_path)
            contents = list(temp_path.glob(f"*{image_name}*"))
            json_path = [_ for _ in contents if _.suffix == '.json'][0]
            json_data = json.loads(json_path.read_text(encoding="utf-8"))
            # we don't need unique names for this tests, strip uuids
            for temp_file in contents:
                if temp_file.suffix == ".json": continue
                new_path = dest_dir / strip_uuid(temp_file.name)
                shutil.copy(temp_file, new_path)
                if 'mask' in temp_file.name:
                    json_data['mask_path'] = str(new_path.relative_to(root_dir))
                elif new_path.stem == image_name:
                    json_data['image_path'] = str(new_path.relative_to(root_dir))
            json_data['original_path'] = str(img_path.relative_to(root_dir))
            json.dump(json_data, open(dest_dir / f"{image_name}#raw.json", "w"), indent=2)
        return json_data
    
    @functools.lru_cache()
    def _load_page_data(self, image_idx: ImgIdT):
        root_dir = self.root_dir
        dest_dir = self.final(self.image_cache_dir(image_idx))
        img_path = self.final(self.image_paths[image_idx])
        image_name = img_path.stem
        # read cached json
        jsons = [_ for _ in dest_dir.glob("*#raw.json") if image_name in _.stem]
        assert len(jsons) <= 1
        # generate text boxes if needed
        if not jsons:
            json_data = self._detect_text(img_path, dest_dir)
        else:
            json_file_path = jsons[0]
            json_data = json.loads(json_file_path.read_text(encoding="utf-8"))
        
        if not all((root_dir / json_data[_]).exists() 
                        for _ in ("image_path", "mask_path", "original_path")):
            raise ValueError(f"Inconsistent page_data of {img_path}")

        page_data = st.PageData(
            json_data["image_path"], json_data["mask_path"], 
            json_data["original_path"], json_data["scale"], 
            [st.Box(*data["xyxy"]) for data in json_data["blk_list"]], 
            [], [], [])
        # Merge boxes that have mutually overlapping centers.
        page_data.resolve_total_overlaps()
        return json_data, page_data

    def page_data(self, image_idx: int):
        _, page_data = self._load_page_data(image_idx)
        return page_data
    def json_data(self, image_idx: int):
        json_data, _ = self._load_page_data(image_idx)
        return json_data

    def path_from_idx(self, image_idx: ImgSpecT, cached: bool = False):
        "(Relative path) to subject image. Raises ValueError if not found."
        _idx = self.normalize_idx(image_idx)
        if _idx is None:
            raise ValueError(f"{_idx} not found in context.")
        if cached:
            page_data = self.page_data(_idx)  # load if needed
            path = Path(page_data.image_path)
        else:
            path = self.image_paths[_idx]
        if not self.final(path).exists():
            raise ValueError(f"{path} not found in context.")
        return path

    def cached_image(self, image_idx: ImgSpecT):
        "Relative path to cached image."
        _idx = self.normalize_idx(image_idx)
        if _idx is None:
            return None
        page_data = self.page_data(_idx)  # load if needed
        path = Path(page_data.image_path)
        if not self.final(path).exists():
            return None
        return path
    
    def image_context(self, image_idx: ImgSpecT) -> ImageContext | None:
        "Cached image context."
        return cast(ImageContext, self.subject_context(image_idx))

    def display_image(self, image_path: Path | str):
        "Return a PIL image, a url, or the given (final) path."
        final_image_path = self.final(image_path)
        if self.force_PIL:
            return Image.open(final_image_path)
        elif self.use_tunnel:
            if (server := self.server) is not None and (url := server.unc_share) is not None:
                return url/final_image_path.relative_to(self.root_dir)
        return final_image_path
    DI = display_image

    def _update_results(self, run_name: str, img_idx: ImgIdT, results: ResultSetDefault):
        self._results[run_name][img_idx] = cast(ResultSet, results)
    
    def _result_from(self, 
            image_idx: ImgIdT, box_idx: BoxIdT, method: CropMethod, ocr: str | None = None):
        img_ctx = ImageContext(self, image_idx)
        extracted = method in _EXTRACTED_METHODS
        result_cls = ResultOCRExtracted if extracted else ResultOCR
        result = result_cls(img_ctx, int(box_idx), None, None, description=f"{method.value}")
        if ocr is not None:
            result.ocr = ocr
        return result
        
    def result(self, 
            run_name: str,
            image_idx: ImgIdT, box_idx: BoxIdT, method: CropMethod, 
            ocr: bool=True, 
            rebuild: bool=False) -> ResultOCR | None:
        _result = self._results[run_name][image_idx][box_idx].get(method)
        if not rebuild and _result is not None:
            return _result
        
        result: ResultOCR = self._result_from(image_idx, box_idx, method)
        image, cropped_image, cropped_mask = result.image, None, None
        img_ctx = ImageContext(self, image_idx)
        base_image = img_ctx.base_image
        box = img_ctx.boxes[box_idx]
        if image is None and method in _IMAGE_METHODS:
            image = crop_by_image(
                    method, box, base_image, self.config.current_profile.preprocessor)

        if image is None and method in _EXTRACTED_METHODS:
            mask = img_ctx.mask
            cropped_image_path = result.cache_image(cropped_image, "cropped")
            cropped_mask_path = result.cache_image(cropped_mask, "mask")
            if not cropped_image_path.exists() or not cropped_mask_path.exists():
                image, cropped_image, cropped_mask = crop_by_extracted(
                    method, box, base_image, mask, 
                    cropped_image_path, cropped_mask_path, img_ctx.dilated())
        
        assert image is not None
        if result.image is None:
            result.image = image
            result.cache_image()
        if cropped_image is not None:
            result.cache_image(cropped_image, "cropped")
        if cropped_mask is not None:
            result.cache_image(cropped_mask, "mask")
        
        exp_run = OCRExperimentRun(self, run_name)
        if ocr:
            exp_run.before_result(result)
            result = self.ocr_box(result, img_ctx.page_lang)
            exp_run.after_result(result)
        self._results[run_name][image_idx][box_idx][method] = result
        self._dirty = True
        return result

    def results(self, run_name: str | None = None, img_idx: ImgIdT | None = None):
        if run_name is None: return self._results
        if img_idx is None: return self._results[run_name]
        return self._results[run_name][img_idx]
    def run_results(self, run_name: str):
        return cast(dict[ImgIdT, ResultSet], self.results(run_name))
    def image_results(self, run_name: str, img_idx: ImgIdT):
        return cast(ResultSet, self.results(run_name, img_idx))
    def box_results(self, run_name: str, img_idx: ImgIdT, box_idx: BoxIdT):
        return cast(ResultSet, self.results(run_name, img_idx))[box_idx]
    def method_results(self, run_name: str, img_idx: ImgIdT, method: CropMethod):
        image_results = self.image_results(run_name, img_idx)
        return {i: box_results.get(method) for i,box_results in image_results.items()}

    def _reset_results(self):
        results = defaultdict(lambda: defaultdict(lambda: ResultSetDefault(dict)))
        self._results = cast(dict[str, dict[ImgIdT, ResultSet]], results)
    def _reset_results_(self, 
            run_name: str | None = None, 
            image_idx: int | None = None, 
            box_idx: int | None = None, 
            method: CropMethod | None = None):
        if run_name is None and image_idx is None and box_idx is None and method is None:
            self._reset_results()
            return
        results = self._results
        models = tuple(results.keys()) if run_name is None else [run_name] if run_name in results else []
        for run_name in models:
            img_nodes = results[run_name]
            imgs = (tuple(img_nodes.keys()) 
                if image_idx is None else [image_idx] if image_idx in img_nodes else [])
            for img_idx in imgs:
                box_nodes = img_nodes[img_idx]
                boxes = (tuple(box_nodes.keys()) 
                    if box_idx is None else [box_idx] if box_idx in box_nodes else [])
                for box_idx in boxes:
                    if method is None:
                        del box_nodes[box_idx]
                    else:
                        methods = box_nodes[box_idx]
                        if method in methods:
                            del methods[method]
                    if not box_nodes[box_idx]:
                        del box_nodes[box_idx]
                if not img_nodes[img_idx]:
                    del img_nodes[img_idx]
            if not results[run_name]:
                del results[run_name]
    def reset_results(self, 
            run_name: str | None = None, 
            image_idx: int | None = None, 
            box_idx: int | None = None, 
            method: CropMethod | None = None):
        self._reset_results_(run_name, image_idx, box_idx, method)
        self._dirty = True
    def _reset_(self):
        super()._reset_()
        self._reset_results_()
        self._load_page_data.cache_clear()
        self.mocr.cache_clear()

    @classmethod
    def get_image_paths(cls, root_dir: Path):
        if root_dir is None: return []
        source_dir = root_dir / cls.SOURCE_DIR_NAME
        return sorted(
            [_.relative_to(root_dir) for _ in source_dir.glob("*") 
                if _.is_file() and _.suffix.lower() in [".jpg", ".png", ".jpeg"]])

    def run_to_dict(self, run_name: RunIdT) -> dict[str, dict[BoxIdT, dict[str, str]]]:
        "JSON serializable dict of the experiment run"
        results = {}
        idx2name = {i: p.name for i, p in enumerate(self.image_paths)}
        run_results = cast(dict[ImgIdT, ResultSet], self.results(run_name))
        for img_idx, rset in run_results.items():
            results[idx2name[img_idx]] = resultset_to_dict(cast(ResultSet, rset))
        return results

    # def run_to_json(self, run_name: RunIdT):
    #     data = {
    #         'run_name': run_name,
    #         'results': self.run_to_dict(run_name),
    #     }
    #     fp = self._root / f'{run_name}.json'
    #     with open(fp, 'w') as f:
    #         json.dump(data, f, indent=2)
    #     return fp

    # def save_results(self):
    #     for run_name, _ in self._exp_runs.items():
    #         self.run_to_json(run_name)
    
    def _load_run_results(self, run_name: str, run_data: dict[str, dict[str, dict[str, str]]]):
        self._exp_runs[run_name] = OCRExperimentRun(self, run_name)
        name2idx = {p.name: i for i, p in enumerate(self.image_paths)}
        for img_name, data in run_data.items():
            img_idx = name2idx.get(img_name, None)
            if img_idx is None: 
                logger.warning(f"Image {img_name} not found in context.")
                continue
            rset: ResultSetDefault = dict_to_resultset(
                ImgIdT(img_idx), 
                data, 
                result_factory=self._result_from)
            self._update_results(run_name, img_idx, rset)

    # def load_results(self):
    #     for json_path in self.root_dir.glob("*.json"):
    #         try:
    #             with open(json_path, 'r') as f:
    #                 data = json.load(f)
    #                 if data.keys() != {'run_name', 'results'}:
    #                     continue
    #         except Exception as e:
    #             continue
    #         self._load_run_results(data)

    def to_dict(self):
        data: dict = {
            "ocr_model": self.ocr_model,
            "runs": (rr := {})
        }
        for run_name, _ in self._exp_runs.items():
            rr[run_name] = self.run_to_dict(run_name)
        return data

    def to_json(self):
        data = self.to_dict()
        _ = datetime.datetime.now()
        fp = self._root / f'{self.name}.json'
        with open(fp, 'w') as f:
            json.dump(data, f, indent=2)
        return fp
    
    def _from_json(self):
        json_path = self.root_dir / f'{self.name}.json'
        if not json_path.exists(): return
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
        except Exception as e:
            logger.error(f"Error loading {json_path}: {e}")
            return
        self.ocr_model = data['ocr_model']
        for run_name, run_results in data['runs'].items():
            self._load_run_results(run_name, run_results)
    
    @classmethod
    def from_json(cls, root_dir: Path, name: str, config: cfg.Config | None = None):
        json_path = root_dir / f'{name}.json'
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
        except Exception as e:
            logger.error(f"Error loading {json_path}: {e}")
            raise e
        config = config or cls.get_config()
        self = cls(data['ocr_model'], root_dir, config=config)
        for run_name, run_results in data['runs'].items():
            self._load_run_results(run_name, run_results)
        return self
    
    def save(self):
        fp = self.to_json()
        self._dirty = False
        return fp

    @classmethod
    def load(cls, root_dir: Path, name: str):
        return cls.from_json(root_dir, name)


    def show(self):
        config = self.config
        gpu = torch.cuda.is_available() or torch.backends.mps.is_available()
        model_path = config.get_model_path(gpu)
        device = ("mps" if torch.backends.mps.is_available() else "cuda") if model_path.suffix == ".pt" else "cpu"

        config.show()
        cprint(
            f"{'config cache_dir':>17}: {repr(config.cache_dir)}\n"
            f"{'model_path':>17}: {repr(model_path)}\n"
            f"{'device':>17}: {repr(device)}")
        
        cprint(
            f"{'force_PIL':>17}: {self.force_PIL}\n"
            f"{'use_tunnel':>17}: {self.use_tunnel}\n"
            f"{'server_url':>17}: {repr(self.server.unc_share) if self.server else ''}\n"
            f"{'experiment dir':>17}: {self.root_dir}\n"
            f"{'source_dir':>17}: {self.final(self.source_dir)}\n"
            f"{'cache_dir':>17}: {self.final(self.cache_dir)}\n"
        )


    def __init__(self, 
            ocr_model: str,
            root_dir: Path | str | None = None, 
            *, 
            config: cfg.Config | None = None, 
            server: web_server.WebServer | None = None,
            run_name: str = 'Tesseract-crop-post',
            load: bool = True):
        if root_dir is None:
            root_dir = type(self).EXP_DIR
        self.config = config or type(self).get_config()
        self.ocr_model = ocr_model
        root_dir = Path(root_dir)
        super().__init__(
            ocr_model, self.get_image_paths(root_dir), root=root_dir, run_name=run_name)
        self.image_paths = self._paths
        self._reset_results()
        self._images = self._subjects
        use_pil = os.environ['USE_PIL'].lower() == 'true'
        self.force_PIL = use_pil
        use_tunnel = os.environ['USE_TUNNEL'].lower() == 'true'
        self.use_tunnel = use_tunnel
        self.server = server or SERVER
        if load:
            self._from_json()


# %% ../nbs/experiments.ipynb 85
@FC.patch_to(ImageContext)
def setup(self, exp: OCRExperimentContext, image_idx: ImgSpecT, page_lang: str | None = None):
    super(type(self), self).setup(exp, image_idx)
    self._mask_dilated1 = self._mask_dilated05 = self._mask_dilated02 = None
    self.json_data, self.page_data = exp._load_page_data(self.idx)
    self.setup_page_lang(page_lang)
    self.mask = Image.open(exp.final(self.mask_path))
    self.base_image = Image.open(exp.final(self.image_path))
    self.setup_ground_truth()


# %% ../nbs/experiments.ipynb 88
class SimpleResultVisor:
    ctx: ResultOCR

    @classmethod
    def diff_tagged(cls, result: ResultOCR):
        _, html = get_text_diffs_html(result.image_ctx.gts[result.block_idx], result.ocr, False)
        return f"<span style='font-size: 14px;'>{html}</span>"

    def as_html(self):
        result = self.ctx
        DI = cast(OCRExperimentContext, result.image_ctx.exp).DI
        if isinstance(result, ResultOCRExtracted):
            return self.as_html_extracted()
        has_ocr = result.ocr is not None
        acc_html = ''
        if has_ocr:
            acc_html = f"<br/><strong><span style='color: red;'>{result.acc:.2f}</span></strong>"
        html_str1, html_str2 = get_text_diffs_html(result.image_ctx.gts[result.block_idx], result.ocr)
        box_image_path = result.cache_image()
        html1 = get_columns_html([[DI(box_image_path)], [(result.ocr or '') + acc_html]])
        if has_ocr:
            html2 = f"<pre style='font-size: 14px;'>{html_str1}<br/>{html_str2}</pre>"
        else:
            html2 = f"<pre style='font-size: 14px;'>{html_str1}</pre>"
        return html1 + '\n<br/>\n' + html2

    def as_html_extracted(self):
        result = self.ctx
        has_ocr = result.ocr is not None
        DI = cast(OCRExperimentContext, result.image_ctx.exp).DI
        html_str1, html_str2 = get_text_diffs_html(result.image_ctx.gts[result.block_idx], result.ocr)
        if has_ocr:
            diff_html = f"<pre style='font-size: 14px;'>{html_str1}<br/>{html_str2}</pre>"
        else:
            diff_html = f"<pre style='font-size: 14px;'>{html_str1}</pre>"
        cropped_image_path = result.cache_image(None, "cropped")
        cropped_mask_path = result.cache_image(None, "mask")
        result_path = result.cache_image()
        return '\n<br/>\n'.join([
            get_image_grid_html([
                DI(cropped_image_path), DI(cropped_mask_path), DI(result_path)], 1, 3), 
            acc_as_html(result.acc) if has_ocr else '', 
            diff_html
        ])
    
    def display(self): display(HTML(self.as_html()))
    def _ipython_display_(self): self.display()

    def __init__(self, ctx: ResultOCR):
        self.ctx = ctx


ResultOCR._default_visor_type = SimpleResultVisor  # type: ignore


# %% ../nbs/experiments.ipynb 107
class RunSelector(ContextVisor):
    def setup_controls(self):
        options = self.run_names
        w = W.Dropdown(
                options=options, 
                value=self.values['run_name'],
                layout={'width': 'fit-content'},
                style={'description_width': 'initial'})
        return {'run_name': w}

    def setup_ui(self):
        ctls = self.controls
        model_grp = W.HBox([ctls['run_name']])
        model_grp.add_class('model_grp')
        ui = W.HBox([*super().comps_ui(), model_grp])
        return ui

    def __init__(self, 
            exp_ctx: OCRExperimentContext,
            run_name: str | None=None,
            run_names: list[str] | None = None,
            **kwargs
        ):
        self.run_names: list[str] = run_names or exp_ctx.run_names
        super().__init__(exp_ctx, 
            {'run_name': run_name or self.run_names[0]})


# %% ../nbs/experiments.ipynb 110
class MessageVisor(ContextVisor):
    EMPTY = '<empty>'

    # _css = """
    #     .message_visor-yXy {
    #         border: 1px solid red;
    #     }
    # """

    @property
    def msg(self): return self.values['msg']
    
    def update_output(self, /, msg: str | None = None, **kwargs):
        if msg is not None and msg != self.EMPTY:
            cprint(msg)
            self.values['msg'] = None
        else:
            clear_output()
        
    def setup_style(self):
        self.out.add_class('message_visor-yXy')
        return super().setup_style()

    def setup_controls(self):
        # w = W.Label(value=self.values['msg'] if self.values['msg'] != self.EMPTY else None, 
        #         layout={'width': 'fit-content'})
        return {}#{'msg': w}

    def __init__(self, 
            msg: str | None = None,
            **kwargs
        ):
        super().__init__(None, 
            {'msg': msg}, 
            **kwargs)


# %% ../nbs/experiments.ipynb 117
class StatusVisor(ContextVisor):
    ctx: OCRExperimentContext

    @property
    def save_button(self) -> W.Button: return self.controls['save']  # type: ignore
    @property
    def reset_button(self) -> W.Button: return self.controls['reset']  # type: ignore
    
    def setup_controls(self):
        style={'font_size': '1em', 'font_weight': 'bold'}
        sw = W.Button(description = 'save', style=style,
                layout={'width': '4em'},
            )
        rw = W.Button(description = 'reset', style=style,
                layout={'width': '5em', 'margin': '0px 0px 0px 3em'},
            )
        return {'save': sw, 'reset': rw}

    def setup_ux(self):
        source = (self.ctx, '_dirty')
        target = (self.save_button, 'disabled')
        T.dlink(source, target, lambda x: not x)
        target = (self.save_button.style, 'button_color')
        T.dlink(source, target, lambda x: 'lightblue' if x else None)
    

    def __init__(self, exp_ctx: OCRExperimentContext, **kwargs):
        super().__init__(exp_ctx, {}, **kwargs)


# %% ../nbs/experiments.ipynb 122
class OCRModelSelector(ContextVisor):
    ctx: OCRExperimentContext
    
    def setup_controls(self):
        options = self.models
        w = W.Dropdown(
                options=options, 
                value=self.values['model'],
                layout={'width': 'fit-content'},
                style={'description_width': 'initial'})
        return {'model': w}

    def setup_ui(self):
        ctls = self.controls
        model_grp = W.HBox([ctls['model']])
        model_grp.add_class('model_grp')
        ui = W.HBox([*super().comps_ui(), model_grp])
        return ui

    def __init__(self, 
            exp_ctx: OCRExperimentContext,
            ocr_model: OCRModel | None=OCRModel.TESSERACT,
            ocr_models: dict[str, OCRModel] | None = None,
            out: W.Output | None = None
        ):
        self.models: dict[str, OCRModel] = ocr_models or OCRModel.__display_names__()
        super().__init__(exp_ctx, 
            {'model': ocr_model or OCRModel.TESSERACT}, 
            out=out or self.out)#, ctxs=[exp_visor])


# %% ../nbs/experiments.ipynb 125
class DisplayOptions(Enum):
    BOXES = 0
    IMAGE = 1
    MASK = 2
    IMAGE_MASK = 3
    PAGE_DATA = 4
    GROUND_TRUTH = 5
    ALL = 6
    RESULTS = 7
    BEST_RESULTS = 8
    ACCURACY = 9
    DATAFRAME = 10
    CONFIG = 11

    @staticmethod
    def __display_names__():
        return dict(
            zip("Boxes, Image, Mask, Image & Mask, Page data, Ground truth, Image All, Results, "
                "Best results, Accuracy, Dataframe, Config".split(', '), 
            DisplayOptions))


class ContentSelector(ContextVisor):
    ctx: OCRExperimentContext

    def image_info(self, image_ctx: ImageContext): 
        img = image_ctx.base_image
        (w, h), print_size_in, print_size_cm, required_dpi = image_ctx.image_info
        format = PRINT_FORMATS['Modern Age']
        cprint( f"{'Width x Height':>30}: {w} x {h} pixels\n"
                f"{'PIL Info DPI':>30}: {repr(img.info.get('dpi', None))}\n"
                f"{'Print Size 300 DPI':>30}: {print_size_in[0]:.3f} x {print_size_in[1]:.3f} in"
                f" / {print_size_cm[0]:.3f} x {print_size_cm[1]:.3f} cm\n"
                f"Required DPI Modern Age format: {required_dpi:.3f} dpi "
                f"({format[0]:.3f} x {format[1]:.3f} in)")


    def display_content(self, image_ctx: ImageContext, display_option: DisplayOptions):
        DI = self.ctx.DI
        if display_option in (DisplayOptions.ALL, DisplayOptions.PAGE_DATA):
            self.image_info(image_ctx)
            RenderJSON(image_ctx.json_data, 350, 2).display()
        if display_option in (DisplayOptions.ALL, DisplayOptions.GROUND_TRUTH):
            cprint(image_ctx.gts)
        if display_option == DisplayOptions.CONFIG:
            self.ctx.show()
        if display_option == DisplayOptions.IMAGE:
            display_image_grid([DI(image_ctx.image_path)], 1, 1)
        if display_option == DisplayOptions.MASK:
            display_image_grid([DI(image_ctx.mask_path)], 1, 1)
        if display_option in (DisplayOptions.ALL, DisplayOptions.IMAGE_MASK):
            display_image_grid([DI(image_ctx.image_path), DI(image_ctx.mask_path)], 1, 2)
        if display_option in (DisplayOptions.ALL, DisplayOptions.BOXES):
            display_image_grid([DI(image_ctx.image_boxes_path)], 1, 1)


    def setup_controls(self):
        options = self.display_options or {**DisplayOptions.__display_names__()}
        display_option_wdgt = W.Dropdown(
                options=options, 
                value=self.values['display_option'],
                layout={'width': '120px'},
                style={'description_width': 'initial'})
        return {'display_option': display_option_wdgt}


    def setup_ui(self):
        ctls = self.controls
        display_option_grp = W.HBox([ctls['display_option']])
        display_option_grp.add_class('display_option_grp')
        comps = self.comps_ui()
        ui = W.HBox([*comps, display_option_grp])
        return ui


    def __init__(self, 
            exp_ctx: OCRExperimentContext,
            display_option: DisplayOptions | None=DisplayOptions.BOXES,
            display_options: Mapping[str, DisplayOptions] | None = None,
            **kwargs
        ):
        self.display_options = display_options
        super().__init__(exp_ctx, 
            {'display_option': display_option or DisplayOptions.BOXES}, 
            **kwargs)#, ctxs=[exp_visor])


# %% ../nbs/experiments.ipynb 129
class ImageSelector(ContextVisor):
    ctx: OCRExperimentContext

    @property
    def image_ctx(self):
        return ImageContext(self.ctx, self.values['image_idx'])
    
    def setup_controls(self):
        paths = self.ctx.image_paths
        w = W.Dropdown(
                options={_.stem:i for i,_ in enumerate(paths)}, 
                value=self.values['image_idx'],
                # layout={'width': 'fit-content'},
                layout={'width': '25em'},
                style={'description_width': 'initial'})
        return {'image_idx': w}

    def update(self, image_idx: ImgSpecT | None = None, **kwargs):
        if image_idx is None: return
        idx = self.ctx.normalize_idx(image_idx)
        if idx is None: return
        super().update(image_idx=idx, **kwargs)


    def __init__(self, 
            ctx: OCRExperimentContext, /, 
            image_idx: ImgSpecT = 0, 
            **kwargs):
        idx = ctx.normalize_idx(image_idx)
        assert idx is not None, f"Image {image_idx} not found in experiment context"
        super().__init__(ctx, {'image_idx': idx}, **kwargs)


# %% ../nbs/experiments.ipynb 133
class OCRContextVisor(ContextVisor):
    ctx: OCRExperimentContext
    
    def update_output(self, /, image_idx: ImgIdT, **kwargs):
        ctx = self.ctx
        img_path = ctx.path_from_idx(image_idx, cached=ctx.force_PIL)
        img = ctx.display_image(img_path)
        display_image_grid([img], 1, 1)

    def update(self, image_idx: ImgSpecT | None = None, **kwargs):
        if image_idx is None: return
        idx = self.ctx.normalize_idx(image_idx)
        if idx is None: return
        super().update(image_idx=idx, **kwargs)
        
    def __init__(self, 
            ctx: OCRExperimentContext, /, 
            image_idx: ImgSpecT = 0, *, 
            out: W.Output | None=None):
        super().__init__(ctx, {}, out, 
                        ctxs={'image_idx': ImageSelector(ctx, image_idx, out=self.out)})


# %% ../nbs/experiments.ipynb 152
class ImageContextVisor(ContextVisor):
    ctx: ImageContext
    # control_names: list[str] = ['display_option']

    _css = """
    .display_option_grp {
        background-color: lightblue;
    }
    """

    def image_info(self): 
        content_selector = cast(ContentSelector, self.comp('display_option'))
        content_selector.image_info(self.ctx)

    def update_output(self, 
            display_option: DisplayOptions | None = None,
            image_idx: ImgIdT | None = None,
            **kwargs):
        content_selector = cast(ContentSelector, self.comp('display_option'))
        if image_idx is not None and image_idx != self.ctx.image_idx:
            ctx = ImageContext(self.ctx.exp, image_idx)
            assert ctx is not None
            self.ctx = ctx
            display_option = content_selector.values['display_option']
        if display_option is None:
            return
        content_selector.display_content(self.ctx, display_option)
        
    def update(self, 
            display_option: DisplayOptions | None=None, 
            image_idx: ImgSpecT | None=None,
            **kwargs):
        if image_idx is not None:
            if (idx := self.ctx.exp.normalize_idx(image_idx)) is not None:
                kwargs['image_idx'] = idx
        super().update(display_option=display_option, **kwargs)

    def __init__(self, 
            exp_ctx: OCRExperimentContext,
            img_idx: ImgSpecT | ImageContext,
            display_option: DisplayOptions=DisplayOptions.BOXES,
            display_options: Mapping[str, DisplayOptions] | None = None,
            out: W.Output | None = None
        ):
        if isinstance(img_idx, ImageContext):
            ctx = img_idx
        else:
            assert exp_ctx is not None, "exp_ctx must be provided if img_idx is not an ImageContext"
            ctx = ImageContext(exp_ctx, img_idx)
            assert ctx is not None, f"Image {img_idx} not found in experiment context"
        if display_options is None:
            display_options = {k: v for k, v in DisplayOptions.__display_names__().items() 
                    if k not in ('Results', 'Accuracy', 'Best results', 'Dataframe', 'Config')}
        out = out or self.out
        content_selector = ContentSelector(exp_ctx, 
                display_option=display_option, display_options=display_options, out=out)
        image_selector = ImageSelector(exp_ctx, ctx.image_idx, out=out)
        super().__init__(ctx, {}, out=out, 
                ctxs={'image_idx': image_selector, 'display_option': content_selector})


# %% ../nbs/experiments.ipynb 165
def trimmed_mean(data, trim_percent):
    sorted_data = np.sort(data)
    n = len(data)
    trim_count = int(trim_percent * n)
    trimmed_data = sorted_data[trim_count:-trim_count]
    return np.mean(trimmed_data)

def mad_based_outlier(points, threshold=3.5):
    median = np.median(points)
    diff = np.abs(points - median)
    mad = np.median(diff)
    modified_z_score = 0.6745 * diff / mad
    return points[modified_z_score < threshold]

def iqr_outlier_removal(data):
    q1 = np.percentile(data, 25)
    q3 = np.percentile(data, 75)
    iqr = q3 - q1
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    return data[(data >= lower_bound) & (data <= upper_bound)]
    

# %% ../nbs/experiments.ipynb 166
class ExperimentOCR:
    ctx: ImageContext
    run: ExperimentRun

    @property
    def ocr_model(self): return cast(OCRExperimentContext, self.ctx.exp).ocr_model
    @property
    def img_ctx(self) -> ImageContext: return self.ctx
    @property
    def ctxs(self) -> tuple[OCRExperimentContext, ImageContext]:
        return cast(OCRExperimentContext, self.img_ctx.exp), self.img_ctx

    def to_dict(self):
        "JSON serializable dict of the experiment"
        results = resultset_to_dict(self.results())
        return {
            'run_name': self.run.name,
            'image_name': self.img_ctx.image_name,
            'results': results,
        }

    @classmethod
    def from_image(cls, 
            ctx: OCRExperimentContext, 
            run_name: RunIdT,
            image_idx: ImgSpecT):
        idx = cast(ImgIdT, ctx.normalize_idx(image_idx))
        img_ctx = ImageContext(ctx, idx)
        return cls(img_ctx, run_name)

    @classmethod
    def from_method(cls, 
            ctx: OCRExperimentContext, 
            image_idx: ImgIdT | str | Path, 
            run_name: str,
            method: CropMethod) -> ExperimentOCRMethod | None:
        experiment = cls.from_image(ctx, run_name, image_idx)
        if experiment is None:
            return None
        return experiment.method_experiment(method)


    def result(self, box_idx: BoxIdT, method: CropMethod, ocr: bool=True, rebuild: bool=False):
        ctx, img_ctx = self.ctxs
        return ctx.result(self.run.name, img_ctx.image_idx, box_idx, method, ocr, rebuild)

    def results(self):
        ctx, img_ctx = self.ctxs
        return cast(ResultSet, ctx.results(self.run.name, img_ctx.image_idx))

    def has_run(self):
        "at least one method has run"
        return len(self.results()) == len(self.img_ctx.page_data.boxes)  # pylint: disable=no-member
    
    def best_results(self):
        methods = list(CropMethod.__members__.values())
        _ = [self.method_experiment(m).results() for m in methods]
        results = self.results()
        # at least one method has run
        if len(results) < len(self.img_ctx.page_data.boxes):    # pylint: disable=no-member
            return None
        best = []
        for box_idx in results:
            methods = results[box_idx]
            best_method = max(methods, key=lambda m: methods[m].acc)  # type: ignore
            best.append((best_method, methods[best_method]))
        return best

    def save_results_as_ground_truth(self, overwrite=False):
        ctx, img_ctx = self.ctxs
        gts_path = ctx.final(ground_truth_path(img_ctx.page_data))  # pylint: disable=no-member
        if overwrite or not gts_path.exists():
            best_results = self.best_results()
            if best_results:
                tt = [r.ocr for m,r in best_results]
                gts_path.write_text('\n'.join(tt), encoding="utf-8")
                img_ctx.setup_ground_truth()
                logger.info(f"Ground truth data saved successfully to {gts_path}")
                return True
            else:
                logger.info("No best results available to save.")
                return False
        else:
            return False

    @property
    def experiments(self):
        if not hasattr(self, '_experiments'):
            self._experiments = {}
        return self._experiments
    def method_experiment(self, method: CropMethod) -> ExperimentOCRMethod:
        if method not in self.experiments:
            self.experiments[method] = ExperimentOCRMethod(self, method)
        return self.experiments[method]
    

    def to_dataframe(self):
        "Dataframe with crop methods as columns and box ids as rows"
        methods = list(CropMethod.__members__.values())
        experiments = [self.method_experiment(m) for m in methods]
        accuracies = [[result.acc for result in exp.results()] for exp in experiments]
        # transpose accuracies
        accuracies = list(zip(*accuracies))
        return pd.DataFrame(accuracies, columns=CropMethod.__display_names__())

    def plot_accuracies(self, 
            methods: list[CropMethod] | None = None, 
        ):
        "Plots a horizontal bar chart of the accuracies for a list of method experiments."
        from matplotlib.colors import Normalize
        methods = methods or list(CropMethod.__members__.values())
        experiments = [self.method_experiment(m) for m in methods]
        if not experiments: return

        _, img_ctx = self.ctxs
        page_data = img_ctx.page_data  # pylint: disable=no-member
        _ = [[result.acc or 0.0 for result in exp.results()] for exp in experiments]
        accuracies: list[float] = [np.mean(a) for a in _]
        # accuracies = [np.mean([result.acc for result in exp.results()]) for exp in experiments]

        _, ax = plt.subplots(figsize=(10, 5))
        
        # Normalize the accuracies for color mapping
        norm = Normalize(min(accuracies), max(accuracies))
        # Color map from red to green
        cmap = plt.get_cmap('RdYlGn')
        colors = cmap(norm(accuracies))

        ax.barh([m.value for m in methods], accuracies, color=colors)

        ax.set_xscale('log')  # Set the x-axis to a logarithmic scale
        ax.set_xlabel('Average Accuracy (log scale)', fontsize=12, fontweight='bold')

        ax.set_ylabel('Method', fontsize=12, fontweight='bold')
        ax.set_yticks(range(len(methods)))
        ax.set_yticklabels([f'{method.value} ({acc:.2f})' 
                for method, acc in zip(methods, accuracies)], fontsize=12)
        max_acc_index = np.argmax(accuracies)
        ax.get_yticklabels()[max_acc_index].set(color='blue', fontweight='bold')

        model = self.ocr_model
        title_text = (f"{page_data.original_path} - OCR model: {model}")
        ax.set_title(title_text, fontsize=12, fontweight='bold')

        plt.tight_layout()
        plt.show()


    def summary_box(self, box_idx: int):
        ctx, _ = self.ctxs
        results: list[tuple[CropMethod, ResultOCR]] = []
        pb = tqdm(CropMethod.__members__.values(), leave=False, desc=f"Box #{box_idx+1}")
        for m in pb:
            r = cast(ResultOCR, self.result(box_idx, m))
            results.append((m, r))
        methods, images, ocrs, accs = zip(*map(
                lambda t: (t[0].value, ctx.DI(t[1].cache_image()), 
                    SimpleResultVisor.diff_tagged(t[1]), acc_as_html(t[1].acc)), 
                results))
        display_columns([methods, images, accs, ocrs], 
                            headers=["Method", f"Box #{box_idx+1}", "Accuracy", "OCR"])


    def summary_method(self, method: CropMethod):
        ctx, _ = self.ctxs
        results = self.method_experiment(method).results()
        methods, images, ocrs, accs = zip(*map(
                lambda r: (r.block_idx+1, ctx.DI(r.cache_image()), 
                SimpleResultVisor.diff_tagged(r), acc_as_html(r.acc)), 
                results))
        display_columns([methods, images, accs, ocrs], 
                headers=["Box #", "Box", "Accuracy", f"{method.value} OCR"])


    def display(self):
        out = []
        for method in CropMethod:
            out.append(f"---------- {method.value} ----------")
            results = self.method_experiment(method).results()
            out.extend(results)
            out.append('\n')
        cprint(*out, soft_wrap=True)


    def reset(self, box_idx: int | None = None, method: CropMethod | None = None):
        ctx, img_ctx = self.ctxs
        ctx.reset_results(None, img_ctx.image_idx, box_idx,  method)

    def perform_methods(self, 
            methods: CropMethod | list[CropMethod] | None = None, 
            box_idxs: BoxIdT | list[BoxIdT] | None = None,
            rebuild: bool = False,
            plot_acc: bool = False
        ):
        if methods is None:
            methods = [*CropMethod.__members__.values()]
        elif isinstance(methods, CropMethod):
            methods = [methods]
        if rebuild:
            _methods = tqdm(methods, desc="Methods")
        else:
            _methods = methods
        for method in _methods:
            method_exp = self.method_experiment(method)
            if method_exp: 
                if rebuild:
                    method_exp(box_idxs, rebuild=rebuild)
        if plot_acc:
            self.plot_accuracies()

    def __call__(self, 
            box_idxs: BoxIdT | list[BoxIdT] | None = None,
            methods: CropMethod | list[CropMethod] | None = None, 
            # save: bool = True,
            display=False, 
            rebuild: bool=False, 
            save_as_ground_truth=False):
        self.perform_methods(methods, box_idxs, rebuild=rebuild)
        if save_as_ground_truth:
            self.save_results_as_ground_truth(overwrite=True)
        # if save:
        #     self.to_json()
        if display:
            self.display()
    
    def __repr__(self):
        return f"ExperimentOCR#{self.ctx.exp.name}_{self.run.name}"
    
    def __init__(self, ctx: ImageContext, run_name: RunIdT, **kwargs):
        # super().__init__(ctx, **kwargs)
        self.ctx = ctx
        run = ctx.exp.experiment_run(run_name)
        assert run is not None
        self.run = run


@dataclasses.dataclass
class ExperimentOCRMethod:
    ctx: ExperimentOCR
    method: CropMethod

    @property
    def exp_ctx(self): return self.ctx
    @property
    def img_ctx(self): return self.ctx.ctx
    @property
    def ctxs(self):
        img_ctx = self.img_ctx
        return cast(OCRExperimentContext, img_ctx.exp), img_ctx, self.ctx
    
    def result(self, box_idx: BoxIdT, ocr: bool=True, rebuild: bool=False) -> ResultOCR | None:
        ctx, img_ctx, exp_ctx = self.ctxs
        return ctx.result(exp_ctx.run.name, img_ctx.image_idx, box_idx, self.method, ocr, rebuild)

    def results(self, 
            box_idxs: BoxIdT | list[BoxIdT] | None = None, 
            ocr: bool=True, rebuild: bool=False) -> list[ResultOCR]:
        ctx, img_ctx, exp_ctx = self.ctxs
        if box_idxs is None:
            box_idxs = list(range(len(img_ctx.boxes)))
        elif isinstance(box_idxs, int):
            box_idxs = [box_idxs]
        run_name = exp_ctx.run.name
        results = ctx.method_results(run_name, img_ctx.image_idx, self.method)
        results = {i:results[i] if i in results else None for i in box_idxs}
        pb = rebuild or not results or any(r is None for r in results.values())
        if pb and len(results) > 2:
            model = exp_ctx.ocr_model
            progress_bar = tqdm(list(results.keys()), desc=f"{self.method.value} - {model}")
        else:
            progress_bar = list(results.keys())
        results = []
        for i in progress_bar:
            results.append(self.result(i, ocr, rebuild=rebuild))
        return results


    def get_results_html(self, 
            box_idxs: BoxIdT | list[BoxIdT] | None = None,
            max_image_width: int | None = None): 
        ctx, img_ctx, exp_ctx = self.ctxs
        results: list[ResultOCR] = self.results(box_idxs)
        accs = np.array([r.acc for r in results])
        mean_accuracy = np.mean(accs)
        mean_trimmed = trimmed_mean(accs, 0.1)
        # filtered_data = mad_based_outlier(accs)
        # mean_mad = np.mean(filtered_data)
        # filtered_data = iqr_outlier_removal(accs)
        # mean_iqr = np.mean(filtered_data)
        
        DI = ctx.DI
        descriptions, images, ocrs, accs = zip(*map(
            lambda r: (
                r.block_idx+1, 
                DI(r.cache_image()), 
                SimpleResultVisor.diff_tagged(r), 
                acc_as_html(r.acc)
            ), results))
        non_breakin_space = u'\u00A0'  # pylint: disable=unused-variable
        tmpl = "<span style='font-family: monospace; white-space: pre-wrap;'>{}</span>"
        padded_s = lambda s,n: tmpl.format(s.rjust(n))
        acc_fmt = f"<strong style='color: red;'>{mean_accuracy:.2f}/{mean_trimmed:.2f}</strong>"
        w, h = img_ctx.base_image.size
        dim, _dpi = size(w, h), dpi(w, h)
        dim_fmt = f"{w}x{h} px: {dim[0]:.2f} x {dim[1]:.2f} in @ {_dpi:.2f} dpi"
        return '\n<br/>\n'.join([
            ("<div style='font-size: 12pt;'>"
            f"{padded_s('Page', 24)}: <strong>{img_ctx.page_data.original_path}</strong><br/>"
            f"{padded_s('Size', 24)}: <strong>{dim_fmt}</strong><br/>"
            f"{padded_s('Run', 24)}: <strong>{exp_ctx.run.name}</strong><br/>"
            f"{padded_s('Model', 24)}: <strong>{exp_ctx.ocr_model}</strong><br/>"
            f"{padded_s('Crop Method', 24)}: <strong>{self.method.value}</strong><br/>"
            f"{padded_s('Accuracy Mean/Trimmed', 24)}: {acc_fmt}"
            "</div>"), 
            get_columns_html(
                [descriptions, images, accs, ocrs], 
                max_image_width, 
                headers=["Box #", "Image", "Accuracy", "OCR"]),
        ])

    def display(self, 
            box_idxs: BoxIdT | list[BoxIdT] | None = None, max_image_width: int | None = None):
        display(HTML(self.get_results_html(box_idxs, max_image_width)))


    def summary(self):
        ctx, _, _ = self.ctxs
        DI = ctx.DI
        results = self.results()
        methods, images, ocrs, accs = zip(*map(
            lambda r: (r.block_idx+1, DI(r.cache_image()), SimpleResultVisor.diff_tagged(r), acc_as_html(r.acc)), 
            results))
        display_columns([methods, images, accs, ocrs], 
                headers=["Box #", "Box", "Accuracy", f"{self.method.value} OCR"])


    def reset(self):
        _, _, exp_ctx = self.ctxs
        exp_ctx.reset(method=self.method)
    
    def __call__(self, box_idxs: BoxIdT | list[BoxIdT] | None = None, display=False, rebuild=False):
        if isinstance(box_idxs, int):
            result = self.result(cast(BoxIdT, box_idxs), rebuild=rebuild)
            if result is not None and display:
                result.display()
        else:
            results = self.results(box_idxs, rebuild=rebuild)
            if results and display:
                self.display(box_idxs)


# %% ../nbs/experiments.ipynb 202
class ResultVisor(ContextVisor):
    ctx: ExperimentOCR
    control_names: list[str] = ['all_boxes', 'box_idx', 'all_methods', 'method']

    _css = """
    .box_grp {
        background-color: aliceblue;
    }
    .method_grp {
        background-color: #ededed;
    }
    """
    
    def best_results(self): 
        ll = self.ctx.best_results()
        if ll:
            cprint([(m.value, f"{r.acc:.3f}", r.ocr) for m,r in ll])

    def pd_to_html(self):
        df = self.ctx.to_dataframe()
        # set float precision
        df = df.round(3)
        # display floats with 3 decimal digits
        df = df.applymap(lambda x: f"{x:.3f}")
        # highlight max value in each row
        stl = df.style.highlight_max(axis=0)
        display(HTML(stl.to_html()))

    def update_output(self, **kwargs):
        all_boxes: bool = self.values['all_boxes']
        box_idx: int = self.values['box_idx']
        all_methods: bool = self.values['all_methods']
        method: CropMethod = self.values['method']

        # cprint(f"all_boxes: {all_boxes}, box_idx: {box_idx}, all_methods: {all_methods}, method: {method}")

        exp, _ = self.ctx.ctxs
        if all_boxes and all_methods:
            self.ctx.plot_accuracies()
            self.ctx.display()
        elif all_boxes:
            self.ctx.summary_method(method)
        elif all_methods:
            self.ctx.summary_box(box_idx)
        else:
            with exp.running(True):
                result = self.ctx.result(box_idx, method)
                if result is not None:
                    result.display()
                    # from time import sleep
                    # sleep(2)

    def setup_controls(self):
        _, img_ctx = self.ctx.ctxs
        values = self.values
        box_wdgt = W.BoundedIntText(
                    value=values['box_idx'], min=0, max=len(img_ctx.boxes)-1, step=1,
                    disabled=values['all_boxes'],
                    layout={'width': '50px'},
                    style={'description_width': 'initial'})
        methods_wdgt = W.Dropdown(
                    options=CropMethod.__display_names__(), 
                    value=values['method'],
                    layout={'width': '150px'},
                    style={'description_width': 'initial'})
        all_boxes_wdgt = W.Checkbox(label='All', value=values['all_boxes'], 
                    description="all", 
                    layout={'width': 'initial'},
                    style={'description_width': '0px'})
        all_methods_wdgt = W.Checkbox(label='All', value=values['all_methods'], 
                    description="all", 
                    layout={'width': 'initial'},
                    style={'description_width': '0px'})
        return {'all_boxes': all_boxes_wdgt, 'box_idx': box_wdgt, 
                'all_methods': all_methods_wdgt, 'method': methods_wdgt}
    
    def setup_ui(self):
        ctls = self.controls
        _, img_ctx = self.ctx.ctxs
        box_label = W.Label(
                value=f"Box # (of {len(img_ctx.boxes)}):", 
                layout={'width': 'initial', 'padding': '0px 0px 0px 10px'})
        method_label = W.Label(value='Method:', layout={'width': 'initial', 'padding': '0px 0px 0px 10px'})

        box_grp = W.HBox([box_label, ctls['all_boxes'], ctls['box_idx']])
        box_grp.add_class('box_grp')
        method_grp = W.HBox([method_label, ctls['all_methods'], ctls['method']])
        method_grp.add_class('method_grp')
        uis = self.comps_ui()
        return W.HBox([box_grp, method_grp, *uis])

    def __init__(self, 
            ctx: OCRExperimentContext | ExperimentOCR,
            img_idx: int | str | Path | None = None,
            all_boxes: bool = False,
            box_idx: int = 0,
            all_methods: bool = False,
            method: CropMethod=CropMethod.INITIAL_BOX,
            **kwargs
        ):
        if isinstance(ctx, OCRExperimentContext):
            assert img_idx is not None, "img_idx must be provided if ctx is an ExperimentContext"
            exp = ExperimentOCR.from_image(ctx, 'Tesseract', img_idx)
            if not exp:
                raise ValueError(f"Image {img_idx} not found in experiment context")
            ctx = exp
        else:
            if not isinstance(ctx, ExperimentOCR):
                raise ValueError("ctx must be an ExperimentOCR or OCRExperimentContext")
        
        super().__init__(ctx, {'all_boxes': all_boxes, 'box_idx': box_idx, 
                            'all_methods': all_methods, 'method': method}, **kwargs)


# %% ../nbs/experiments.ipynb 205
class ExperimentVisor(ContextVisor):
    ctx: ExperimentOCR

    def update_output(self, 
            image_idx: int | None = None,
            **kwargs):
        exp_ctx, img_ctx = self.ctx.ctxs
        if image_idx is not None and image_idx != img_ctx.image_idx:
            ctx = ImageContext(exp_ctx, image_idx)
            assert ctx is not None
            self.ctx.ctx = ctx
        result_visor = self.comp('result_visor')
        if result_visor is not None:
            result_visor.update_output(**kwargs)

    def __init__(self, 
            ctx: OCRExperimentContext | ExperimentOCR,
            img_idx: int | str | Path | None = None,
            all_boxes: bool = False,
            box_idx: int = 0,
            all_methods: bool = False,
            method: CropMethod=CropMethod.INITIAL_BOX,
            out: W.Output | None = None,
        ):
        if isinstance(ctx, OCRExperimentContext):
            assert img_idx is not None, "img_idx must be provided if ctx is an ExperimentContext"
            exp = ExperimentOCR.from_image(ctx, 'Tesseract', img_idx)
            if not exp:
                raise ValueError(f"Image {img_idx} not found in experiment context")
            ctx = exp
        else:
            if not issubclass(type(ctx), ExperimentOCR):
                raise ValueError("ctx must be an ExperimentOCR or OCRExperimentContext")
        
        exp_ctx, img_ctx = ctx.ctxs
        out = out or self.out
        image_selector = ImageSelector(exp_ctx, image_idx=img_ctx.image_idx, out=out)
        result_visor = ResultVisor(ctx, out=out,
            all_boxes=all_boxes, box_idx=box_idx, all_methods=all_methods, method=method)

        super().__init__(ctx, {}, out=out, 
                    ctxs={'image_selector': image_selector, 'result_visor': result_visor},
                    hdlrs={'display_option': result_visor}
                    )


# %% ../nbs/experiments.ipynb 253
class ExperimentsVisor(ContextVisor):
    ctx: OCRExperimentContext

    def update_output(self, 
            run_name: RunIdT | None = None,
            image_idx: ImgIdT | None = None,
            display_option: DisplayOptions | None = None, 
            msg: str | None = None,
            **kwargs):
        (run_selector, image_selector, content_selector, 
            result_visor, _, message_visor) = self._comps()
        if msg is not None and msg != MessageVisor.EMPTY:
            message_visor.update_output(msg=msg)
        if run_name is not None:
            run = OCRExperimentRun(run_selector.ctx, run_name)
            exp_ctx = result_visor.ctx
            exp_ctx.run = run
            result_visor.ctx = exp_ctx
        if image_idx is not None:
            img_ctx = ImageContext(self.ctx, image_idx)
            result_visor.ctx.ctx = img_ctx
            display_option = content_selector.values['display_option']
        if display_option is not None and display_option != DisplayOptions.RESULTS:
            result_visor.hide()
            if display_option == DisplayOptions.BEST_RESULTS:
                result_visor.best_results()
            elif display_option == DisplayOptions.ACCURACY:
                result_visor.ctx.plot_accuracies()
            elif display_option == DisplayOptions.DATAFRAME:
                result_visor.pd_to_html()
            else:
                content_selector.display_content(image_selector.image_ctx, display_option)
        else:
            result_visor.show()
            result_visor.update_output(**kwargs)


    @property
    def status_visor(self) -> StatusVisor: return cast(StatusVisor, self.comps['status_visor'])
    @property
    def message_visor(self) -> MessageVisor: return cast(MessageVisor, self.comps['message_visor'])
    @property
    def image_context(self) -> ImageContext: 
        return ImageContext(self.ctx, self.comps['image_selector'].values['image_idx'])
    @property
    def run_name(self) -> str: return cast(str, self.comps['run_selector'].values['run_name'])
    @property
    def image_experiment(self) -> ExperimentOCR: return ExperimentOCR(self.image_context, self.run_name)

    def _comps(self):
        cc = self.comps
        rsel: RunSelector = cc['run_selector']  # type: ignore
        isel: ImageSelector = cc['image_selector']  # type: ignore
        cs: ContentSelector = cc['content_selector']  # type: ignore
        rv: ResultVisor = cc['result_visor']  # type: ignore
        sv: StatusVisor = cc['status_visor']  # type: ignore
        mv: MessageVisor = cc['message_visor']  # type: ignore
        return rsel, isel, cs, rv, sv, mv

    def setup_ui(self):
        ctls = self.controls.values()
        rselw, iselw, csw, rvw, svw, _ = [_.w for _ in self._comps()]
        return W.VBox([W.HBox([rselw, iselw, csw, svw, *ctls]), rvw])

    def save(self, b):
        ctx = self.ctx
        fp = ctx.save()
        self.update(msg=f"'{ctx.name}' experiment saved on {fp}")

    def reset(self, b): 
        image_idx = self.comps['image_selector'].values['image_idx']
        self.ctx.reset_results(image_idx=image_idx)

    def setup_ux(self):
        self.status_visor.save_button.on_click(self.save)
        self.status_visor.reset_button.on_click(self.reset)

    def setup_experiment_context(self, 
            ocr_model: str | None = None,
            root_dir: Path | str | None = None, 
            config: cfg.Config | None = None, 
            run_names: list[str] | None = None,
        ):
        ctx = OCRExperimentContext(ocr_model or 'Tesseract', root_dir, config=config)  # type: ignore
                    
        for run_name in run_names or ['Tesseract-crop-post', 'Tesseract-crop']:
            OCRExperimentRun(ctx, run_name)
        return ctx

    def __init__(self, 
            ctx: OCRExperimentContext | None = None, 
            ocr_model: str | None = None,
            root_dir: Path | str | None = None, 
            config: cfg.Config | None = None, 
            image_idx: ImgIdT | str | Path = 0,
            run_name: str | None = None, 
            run_names: list[str] | None = None,
            display_option: DisplayOptions = DisplayOptions.RESULTS,
            all_boxes: bool = False,
            box_idx: int = 0,
            all_methods: bool = False,
            method: CropMethod=CropMethod.INITIAL_BOX,
            # ocr_model: OCRModel = OCRModel.TESSERACT,
            # ocr_models: dict[str, OCRModel] = {'Tesseract': OCRModel.TESSERACT},
            out: W.Output | None = None,
        ):
        if ctx is None:
            ctx = self.setup_experiment_context(ocr_model, root_dir, config, run_names)
        _ = ImageContext(ctx, image_idx)  # raises if image_idx is out of range
        
        out = out or self.out
        run_selector = RunSelector(ctx, run_name, run_names, out=out)
        exp = ExperimentOCR.from_image(ctx, run_selector.values['run_name'], image_idx)
        image_selector = ImageSelector(ctx, image_idx=image_idx, out=out)
        content_selector = ContentSelector(ctx, display_option=display_option, out=out)
        result_visor = ResultVisor(exp, out=out,
            all_boxes=all_boxes, box_idx=box_idx, all_methods=all_methods, method=method,
            ctxs={'spinner': Spinner(ctx, 20, 3)}
            )
        status_visor = StatusVisor(ctx, out=None)
        message_visor = MessageVisor(MessageVisor.EMPTY, out=out)
        
        super().__init__(ctx, {}, out=out, 
                    ctxs={'run_selector': run_selector, #'model_selector': model_selector, 
                        'image_selector': image_selector, 'content_selector': content_selector, 
                        'result_visor': result_visor, 
                        'status_visor': status_visor, 
                        'message_visor': message_visor,
                        },
                    )

